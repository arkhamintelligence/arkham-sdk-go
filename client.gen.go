// Package arkham provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package arkham

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/oapi-codegen/runtime"
)

// pass

// GetAccountAirdropsResponseBody defines body from GetAccountAirdrops response
type GetAccountAirdropsResponseBody = []Airdrop

// GetAccountBalanceUpdatesResponseBody defines body from GetAccountBalanceUpdates response
type GetAccountBalanceUpdatesResponseBody = []BalanceUpdate

// GetBalancesResponseBody defines body from GetBalances response
type GetBalancesResponseBody = []Balance

// GetAllBalancesResponseBody defines body from GetAllBalances response
type GetAllBalancesResponseBody = []Balance

// GetPortfolioBalanceHistoryResponseBody defines body from GetPortfolioBalanceHistory response
type GetPortfolioBalanceHistoryResponseBody = []HistoricBalance

// GetAccountCommissionsResponseBody defines body from GetAccountCommissions response
type GetAccountCommissionsResponseBody = []Commission

// GetDepositAddressesResponseBody defines body from GetDepositAddresses response
type GetDepositAddressesResponseBody = DepositAddressesResponse

// NewDepositAddressResponseBody defines body from NewDepositAddress response
type NewDepositAddressResponseBody = NewDepositAddressResponse

// GetAccountDepositsResponseBody defines body from GetAccountDeposits response
type GetAccountDepositsResponseBody = []Deposit

// GetUserFeesResponseBody defines body from GetUserFees response
type GetUserFeesResponseBody = UserFees

// GetFundingRatePaymentsResponseBody defines body from GetFundingRatePayments response
type GetFundingRatePaymentsResponseBody = []FundingRatePayment

// GetPositionLeverageResponseBody defines body from GetPositionLeverage response
type GetPositionLeverageResponseBody = []PositionLeverage

// GetLiquidationPriceResponseBody defines body from GetLiquidationPrice response
type GetLiquidationPriceResponseBody = LiquidationPrice

// GetAccountLspAssignmentsResponseBody defines body from GetAccountLspAssignments response
type GetAccountLspAssignmentsResponseBody = []LspAssignment

// GetMarginResponseBody defines body from GetMargin response
type GetMarginResponseBody = Margin

// GetAllMarginResponseBody defines body from GetAllMargin response
type GetAllMarginResponseBody = []Margin

// GetNotificationsResponseBody defines body from GetNotifications response
type GetNotificationsResponseBody = []Notification

// MarkReadNotificationsResponseBody defines body from MarkReadNotifications response
type MarkReadNotificationsResponseBody = string

// GetAccountPositionUpdatesResponseBody defines body from GetAccountPositionUpdates response
type GetAccountPositionUpdatesResponseBody = []PositionUpdate

// GetPositionsResponseBody defines body from GetPositions response
type GetPositionsResponseBody = []Position

// GetAccountRealizedPnlResponseBody defines body from GetAccountRealizedPnl response
type GetAccountRealizedPnlResponseBody = []RealizedPnl

// GetAccountRebatesResponseBody defines body from GetAccountRebates response
type GetAccountRebatesResponseBody = []Rebate

// GetReferralLinksResponseBody defines body from GetReferralLinks response
type GetReferralLinksResponseBody = []ReferralLink

// CreateReferralLinkResponseBody defines body from CreateReferralLink response
type CreateReferralLinkResponseBody = ReferralLinkResponse

// GetActiveSessionsResponseBody defines body from GetActiveSessions response
type GetActiveSessionsResponseBody = SessionsResponse

// GetUserSettingsResponseBody defines body from GetUserSettings response
type GetUserSettingsResponseBody = UserSettings

// GetPriceAlertResponseBody defines body from GetPriceAlert response
type GetPriceAlertResponseBody = PriceAlert

// UpdateUserSettingsResponseBody defines body from UpdateUserSettings response
type UpdateUserSettingsResponseBody = string

// GetAccountTransfersResponseBody defines body from GetAccountTransfers response
type GetAccountTransfersResponseBody = []Transfer

// GetAccountWatchlistResponseBody defines body from GetAccountWatchlist response
type GetAccountWatchlistResponseBody = []string

// AccountWithdrawResponseBody defines body from AccountWithdraw response
type AccountWithdrawResponseBody = int

// AccountWithdrawUsingMFAResponseBody defines body from AccountWithdrawUsingMFA response
type AccountWithdrawUsingMFAResponseBody = int

// ListWithdrawalAddressesResponseBody defines body from ListWithdrawalAddresses response
type ListWithdrawalAddressesResponseBody = []WithdrawalAddress

// CreateWithdrawalAddressResponseBody defines body from CreateWithdrawalAddress response
type CreateWithdrawalAddressResponseBody = int

// ConfirmWithdrawalAddressResponseBody defines body from ConfirmWithdrawalAddress response
type ConfirmWithdrawalAddressResponseBody = string

// DeleteWithdrawalAddressResponseBody defines body from DeleteWithdrawalAddress response
type DeleteWithdrawalAddressResponseBody = string

// GetWithdrawalAddressResponseBody defines body from GetWithdrawalAddress response
type GetWithdrawalAddressResponseBody = WithdrawalAddress

// UpdateWithdrawalAddressLabelResponseBody defines body from UpdateWithdrawalAddressLabel response
type UpdateWithdrawalAddressLabelResponseBody = string

// GetAccountWithdrawalsResponseBody defines body from GetAccountWithdrawals response
type GetAccountWithdrawalsResponseBody = []Withdrawal

// CommissionsEarnedResponseBody defines body from CommissionsEarned response
type CommissionsEarnedResponseBody = string

// MinArkmLast30dResponseBody defines body from MinArkmLast30d response
type MinArkmLast30dResponseBody = string

// UserPointsResponseBody defines body from UserPoints response
type UserPointsResponseBody = UserPoints

// UserPointsSeason1ResponseBody defines body from UserPointsSeason1 response
type UserPointsSeason1ResponseBody = UserPoints

// UserPointsSeason2ResponseBody defines body from UserPointsSeason2 response
type UserPointsSeason2ResponseBody = UserPoints

// RealizedPnlResponseBody defines body from RealizedPnl response
type RealizedPnlResponseBody = []SizeTimeSeries

// RebateBalanceResponseBody defines body from RebateBalance response
type RebateBalanceResponseBody = string

// ReferralCountResponseBody defines body from ReferralCount response
type ReferralCountResponseBody = int

// UserReferralsSeason1ResponseBody defines body from UserReferralsSeason1 response
type UserReferralsSeason1ResponseBody = int

// UserReferralsSeason2ResponseBody defines body from UserReferralsSeason2 response
type UserReferralsSeason2ResponseBody = int

// TradingVolumeStatsResponseBody defines body from TradingVolumeStats response
type TradingVolumeStatsResponseBody = TradingVolumeStats

// UserVolumeSeason1ResponseBody defines body from UserVolumeSeason1 response
type UserVolumeSeason1ResponseBody = TradingVolume

// UserVolumeSeason2ResponseBody defines body from UserVolumeSeason2 response
type UserVolumeSeason2ResponseBody = TradingVolume

// GetAirdropAddressResponseBody defines body from GetAirdropAddress response
type GetAirdropAddressResponseBody = string

// CreateAirdropAddressResponseBody defines body from CreateAirdropAddress response
type CreateAirdropAddressResponseBody = string

// GetAirdropClaimResponseBody defines body from GetAirdropClaim response
type GetAirdropClaimResponseBody = AirdropClaim

// ApiKeysListResponseBody defines body from ApiKeysList response
type ApiKeysListResponseBody = []ApiKey

// ApiKeyCreateResponseBody defines body from ApiKeyCreate response
type ApiKeyCreateResponseBody = ApiKeyWithSecret

// ApiKeyUpdateResponseBody defines body from ApiKeyUpdate response
type ApiKeyUpdateResponseBody = string

// CompetitionOptInStatusResponseBody defines body from CompetitionOptInStatus response
type CompetitionOptInStatusResponseBody = bool

// DexPriceResponseBody defines body from DexPrice response
type DexPriceResponseBody = AllowanceHolderBaseResponse

// DexQuoteResponseBody defines body from DexQuote response
type DexQuoteResponseBody = AllowanceHolderBaseResponse

// GetDexTokenListResponseBody defines body from GetDexTokenList response
type GetDexTokenListResponseBody = []DexToken

// DexTradeHistoryResponseBody defines body from DexTradeHistory response
type DexTradeHistoryResponseBody = []DexTradeHistoryItem

// GetOrdersResponseBody defines body from GetOrders response
type GetOrdersResponseBody = []Order

// GetOpenOrderByClientOrderIdResponseBody defines body from GetOpenOrderByClientOrderId response
type GetOpenOrderByClientOrderIdResponseBody = Order

// CancelOrderResponseBody defines body from CancelOrder response
type CancelOrderResponseBody = CancelOrderResponse

// CancelReplaceOrderResponseBody defines body from CancelReplaceOrder response
type CancelReplaceOrderResponseBody = CancelReplaceOrderResponse

// GetOrderHistoryResponseBody defines body from GetOrderHistory response
type GetOrderHistoryResponseBody = []Order

// GetAllOrdersByClientOrderIdResponseBody defines body from GetAllOrdersByClientOrderId response
type GetAllOrdersByClientOrderIdResponseBody = []Order

// GetOrderHistoryWithTotalResponseBody defines body from GetOrderHistoryWithTotal response
type GetOrderHistoryWithTotalResponseBody = OrderHistoryWithTotalResponse

// CreateOrderResponseBody defines body from CreateOrder response
type CreateOrderResponseBody = CreateOrderResponse

// CreateOrderBatchResponseBody defines body from CreateOrderBatch response
type CreateOrderBatchResponseBody = CreateOrdersBatchResponse

// CreateSimpleOrderResponseBody defines body from CreateSimpleOrder response
type CreateSimpleOrderResponseBody = CreateOrderResponse

// GetOrderByIdResponseBody defines body from GetOrderById response
type GetOrderByIdResponseBody = Order

// GetAlertsResponseBody defines body from GetAlerts response
type GetAlertsResponseBody = []Alert

// GetAnnouncementsResponseBody defines body from GetAnnouncements response
type GetAnnouncementsResponseBody = []Announcement

// GetAssetsResponseBody defines body from GetAssets response
type GetAssetsResponseBody = []Asset

// GetBookResponseBody defines body from GetBook response
type GetBookResponseBody = OrderBook

// GetCandlesResponseBody defines body from GetCandles response
type GetCandlesResponseBody = []Candle

// GetChainsResponseBody defines body from GetChains response
type GetChainsResponseBody = []Blockchain

// GetContractsResponseBody defines body from GetContracts response
type GetContractsResponseBody = []Ticker

// GetIndexPriceResponseBody defines body from GetIndexPrice response
type GetIndexPriceResponseBody = IndexPrice

// GetIndexPricesResponseBody defines body from GetIndexPrices response
type GetIndexPricesResponseBody = []IndexPrice

// GetL1BookResponseBody defines body from GetL1Book response
type GetL1BookResponseBody = L1OrderBook

// GetMarginSchedulesResponseBody defines body from GetMarginSchedules response
type GetMarginSchedulesResponseBody = []MarginSchedule

// GetMarketCapChartResponseBody defines body from GetMarketCapChart response
type GetMarketCapChartResponseBody = MarketCapHistoricData

// GetMarketCapsResponseBody defines body from GetMarketCaps response
type GetMarketCapsResponseBody = MarketCapResponse

// GetPairResponseBody defines body from GetPair response
type GetPairResponseBody = Pair

// GetPairsResponseBody defines body from GetPairs response
type GetPairsResponseBody = []Pair

// ServerTimeResponseBody defines body from ServerTime response
type ServerTimeResponseBody = ServerTimeResponse

// GetTickerResponseBody defines body from GetTicker response
type GetTickerResponseBody = Ticker

// GetTickersResponseBody defines body from GetTickers response
type GetTickersResponseBody = []Ticker

// GetPublicTradesResponseBody defines body from GetPublicTrades response
type GetPublicTradesResponseBody = PublicTradesResponse

// RewardsInfoResponseBody defines body from RewardsInfo response
type RewardsInfoResponseBody = RewardsInfo

// VouchersResponseBody defines body from Vouchers response
type VouchersResponseBody = []RewardsVoucher

// GetSubaccountsResponseBody defines body from GetSubaccounts response
type GetSubaccountsResponseBody = []SubaccountWithSettings

// CreateSubaccountResponseBody defines body from CreateSubaccount response
type CreateSubaccountResponseBody = CreateSubaccountResponse

// CreatePerpTransferResponseBody defines body from CreatePerpTransfer response
type CreatePerpTransferResponseBody = CreatePerpTransferResponse

// CreateTransferResponseBody defines body from CreateTransfer response
type CreateTransferResponseBody = CreateTransferResponse

// UpdatePortfolioSettingsResponseBody defines body from UpdatePortfolioSettings response
type UpdatePortfolioSettingsResponseBody = string

// GetUserTradesResponseBody defines body from GetUserTrades response
type GetUserTradesResponseBody = []UserTrade

// GetUserTradesWithTotalsResponseBody defines body from GetUserTradesWithTotals response
type GetUserTradesWithTotalsResponseBody = UserTradesWithTotalsResponse

// GetUserTradesByTimeResponseBody defines body from GetUserTradesByTime response
type GetUserTradesByTimeResponseBody = []UserTrade

// GetTriggerOrdersResponseBody defines body from GetTriggerOrders response
type GetTriggerOrdersResponseBody = []TriggerOrder

// CancelTriggerOrderResponseBody defines body from CancelTriggerOrder response
type CancelTriggerOrderResponseBody = CancelTriggerOrderResponse

// CancelAllTriggerOrdersResponseBody defines body from CancelAllTriggerOrders response
type CancelAllTriggerOrdersResponseBody = CancelAllTriggerOrdersResponse

// CreateTriggerOrderResponseBody defines body from CreateTriggerOrder response
type CreateTriggerOrderResponseBody = CreateTriggerOrderResponse

// GetUserResponseBody defines body from GetUser response
type GetUserResponseBody = UserDisplay

// Get Airdrops
//
// Get the user's airdrops
func (c *Client) GetAccountAirdrops(ctx context.Context, params GetAccountAirdropsParams) (*GetAccountAirdropsResponseBody, error) {
	req, err := newGetAccountAirdropsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountAirdropsResponseBody](rsp)

}

// Get Balance Updates
//
// Get the user's balance updates
func (c *Client) GetAccountBalanceUpdates(ctx context.Context, params GetAccountBalanceUpdatesParams) (*GetAccountBalanceUpdatesResponseBody, error) {
	req, err := newGetAccountBalanceUpdatesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountBalanceUpdatesResponseBody](rsp)

}

// Get Balances
//
// Get the user's current balances
func (c *Client) GetBalances(ctx context.Context, params GetBalancesParams) (*GetBalancesResponseBody, error) {
	req, err := newGetBalancesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetBalancesResponseBody](rsp)

}

// Get Balances across all subaccounts
//
// Get the user's current balances across all subaccounts
func (c *Client) GetAllBalances(ctx context.Context) (*GetAllBalancesResponseBody, error) {
	req, err := newGetAllBalancesRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAllBalancesResponseBody](rsp)

}

// Get User Subaccount Balance History
//
// Get the balance history for a subaccount
func (c *Client) GetPortfolioBalanceHistory(ctx context.Context, params GetPortfolioBalanceHistoryParams) (*GetPortfolioBalanceHistoryResponseBody, error) {
	req, err := newGetPortfolioBalanceHistoryRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPortfolioBalanceHistoryResponseBody](rsp)

}

// Get Commissions
//
// Get the user's commissions
func (c *Client) GetAccountCommissions(ctx context.Context, params GetAccountCommissionsParams) (*GetAccountCommissionsResponseBody, error) {
	req, err := newGetAccountCommissionsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountCommissionsResponseBody](rsp)

}

// Get Deposit Addresses
func (c *Client) GetDepositAddresses(ctx context.Context, params GetDepositAddressesParams) (*GetDepositAddressesResponseBody, error) {
	req, err := newGetDepositAddressesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetDepositAddressesResponseBody](rsp)

}

// Create Deposit Address
func (c *Client) NewDepositAddress(ctx context.Context, body NewDepositAddressRequest) (*NewDepositAddressResponseBody, error) {
	req, err := newNewDepositAddressRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[NewDepositAddressResponseBody](rsp)

}

// Get Deposits
func (c *Client) GetAccountDeposits(ctx context.Context, params GetAccountDepositsParams) (*GetAccountDepositsResponseBody, error) {
	req, err := newGetAccountDepositsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountDepositsResponseBody](rsp)

}

// Get User Fees
//
// Get the user's current trading fees
func (c *Client) GetUserFees(ctx context.Context) (*GetUserFeesResponseBody, error) {
	req, err := newGetUserFeesRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserFeesResponseBody](rsp)

}

// Get Funding Rate Payments
//
// Get the user's funding rate payments
func (c *Client) GetFundingRatePayments(ctx context.Context, params GetFundingRatePaymentsParams) (*GetFundingRatePaymentsResponseBody, error) {
	req, err := newGetFundingRatePaymentsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetFundingRatePaymentsResponseBody](rsp)

}

// Get Position Limits
//
// Gets the user specified position leverage
func (c *Client) GetPositionLeverage(ctx context.Context, params GetPositionLeverageParams) (*GetPositionLeverageResponseBody, error) {
	req, err := newGetPositionLeverageRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPositionLeverageResponseBody](rsp)

}

// Get Position Limits
//
// Sets the user specified position leverage for a given pair
func (c *Client) SetPositionLeverage(ctx context.Context, body SetPositionLeverageRequest) error {
	req, err := newSetPositionLeverageRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Liquidation Price
//
// Get liquidation price for a perpetual position
func (c *Client) GetLiquidationPrice(ctx context.Context, params GetLiquidationPriceParams) (*GetLiquidationPriceResponseBody, error) {
	req, err := newGetLiquidationPriceRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetLiquidationPriceResponseBody](rsp)

}

// Get LSP Assignments
//
// Get the user's lsp assignments
func (c *Client) GetAccountLspAssignments(ctx context.Context, params GetAccountLspAssignmentsParams) (*GetAccountLspAssignmentsResponseBody, error) {
	req, err := newGetAccountLspAssignmentsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountLspAssignmentsResponseBody](rsp)

}

// Get Account Margin
//
// Get the user's current margin usage details
func (c *Client) GetMargin(ctx context.Context, params GetMarginParams) (*GetMarginResponseBody, error) {
	req, err := newGetMarginRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetMarginResponseBody](rsp)

}

// Get Account Margin across all subaccounts
//
// Get the user's current margin usage details
func (c *Client) GetAllMargin(ctx context.Context) (*GetAllMarginResponseBody, error) {
	req, err := newGetAllMarginRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAllMarginResponseBody](rsp)

}

// Get Notifications
func (c *Client) GetNotifications(ctx context.Context, params GetNotificationsParams) (*GetNotificationsResponseBody, error) {
	req, err := newGetNotificationsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetNotificationsResponseBody](rsp)

}

// Mark Notifications Read
func (c *Client) MarkReadNotifications(ctx context.Context, body MarkReadNotificationsRequest) (*MarkReadNotificationsResponseBody, error) {
	req, err := newMarkReadNotificationsRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[MarkReadNotificationsResponseBody](rsp)

}

// Get Position Updates
//
// Get the user's position updates
func (c *Client) GetAccountPositionUpdates(ctx context.Context, params GetAccountPositionUpdatesParams) (*GetAccountPositionUpdatesResponseBody, error) {
	req, err := newGetAccountPositionUpdatesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountPositionUpdatesResponseBody](rsp)

}

// Get Positions
//
// Get list of the current positions
func (c *Client) GetPositions(ctx context.Context, params GetPositionsParams) (*GetPositionsResponseBody, error) {
	req, err := newGetPositionsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPositionsResponseBody](rsp)

}

// Get Realized PnL
//
// Get the user's realized pnl
func (c *Client) GetAccountRealizedPnl(ctx context.Context, params GetAccountRealizedPnlParams) (*GetAccountRealizedPnlResponseBody, error) {
	req, err := newGetAccountRealizedPnlRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountRealizedPnlResponseBody](rsp)

}

// Get Rebates
//
// Get the user's rebates
func (c *Client) GetAccountRebates(ctx context.Context, params GetAccountRebatesParams) (*GetAccountRebatesResponseBody, error) {
	req, err := newGetAccountRebatesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountRebatesResponseBody](rsp)

}

// Get Referral Links
//
// Get the user's referral links
func (c *Client) GetReferralLinks(ctx context.Context) (*GetReferralLinksResponseBody, error) {
	req, err := newGetReferralLinksRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetReferralLinksResponseBody](rsp)

}

// Create Referral Link
//
// Create a referral link for the user
func (c *Client) CreateReferralLink(ctx context.Context) (*CreateReferralLinkResponseBody, error) {
	req, err := newCreateReferralLinkRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateReferralLinkResponseBody](rsp)

}

// Update Referral Link Slug
//
// Update the slug for a referral link
func (c *Client) UpdateReferralLinkSlug(ctx context.Context, id string, body UpdateReferralLinkSlugRequest) error {
	req, err := newUpdateReferralLinkSlugRequest(ctx, c.apiURL, c.keyPair, id, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Active Sessions
//
// Get the user's active sessions
func (c *Client) GetActiveSessions(ctx context.Context) (*GetActiveSessionsResponseBody, error) {
	req, err := newGetActiveSessionsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetActiveSessionsResponseBody](rsp)

}

// Delete Session
//
// Delete a session for the user
func (c *Client) HandleDeleteSession(ctx context.Context, body DeleteSessionRequest) error {
	req, err := newHandleDeleteSessionRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Terminate All Sessions
//
// Terminate all sessions for the user
func (c *Client) HandleTerminateAll(ctx context.Context) error {
	req, err := newHandleTerminateAllRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get User Settings
func (c *Client) GetUserSettings(ctx context.Context) (*GetUserSettingsResponseBody, error) {
	req, err := newGetUserSettingsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserSettingsResponseBody](rsp)

}

// Delete Price Alert
func (c *Client) DeletePriceAlert(ctx context.Context, params DeletePriceAlertParams) error {
	req, err := newDeletePriceAlertRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Price Alerts
func (c *Client) GetPriceAlert(ctx context.Context, params GetPriceAlertParams) (*GetPriceAlertResponseBody, error) {
	req, err := newGetPriceAlertRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPriceAlertResponseBody](rsp)

}

// Set Price Alert
func (c *Client) SetPriceAlert(ctx context.Context, params SetPriceAlertParams, body SetPriceAlertRequest) error {
	req, err := newSetPriceAlertRequest(ctx, c.apiURL, c.keyPair, params, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Update User Settings
func (c *Client) UpdateUserSettings(ctx context.Context, body UpdateUserSettingsRequest) (*UpdateUserSettingsResponseBody, error) {
	req, err := newUpdateUserSettingsRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UpdateUserSettingsResponseBody](rsp)

}

// Get Transfers
func (c *Client) GetAccountTransfers(ctx context.Context, params GetAccountTransfersParams) (*GetAccountTransfersResponseBody, error) {
	req, err := newGetAccountTransfersRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountTransfersResponseBody](rsp)

}

// Unsubscribe from Reminder Emails
//
// Unsubscribe from reminder emails using the link from an email
func (c *Client) HandleReminderEmailUnsubscribe(ctx context.Context, params HandleReminderEmailUnsubscribeParams) error {
	req, err := newHandleReminderEmailUnsubscribeRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Watchlist
//
// Get a list of the pairs in your watchlist
func (c *Client) GetAccountWatchlist(ctx context.Context) (*GetAccountWatchlistResponseBody, error) {
	req, err := newGetAccountWatchlistRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountWatchlistResponseBody](rsp)

}

// Add to Watchlist
//
// Add a pair to the watchlist
func (c *Client) AddToWatchlist(ctx context.Context, body AddToWatchlistRequest) error {
	req, err := newAddToWatchlistRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Remove from Watchlist
//
// Remove a pair from your watchlise
func (c *Client) RemoveFromWatchlist(ctx context.Context, body RemoveFromWatchlistRequest) error {
	req, err := newRemoveFromWatchlistRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Account Withdraw
func (c *Client) AccountWithdraw(ctx context.Context, body AccountWithdrawRequest) (*AccountWithdrawResponseBody, error) {
	req, err := newAccountWithdrawRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[AccountWithdrawResponseBody](rsp)

}

// Account Withdraw With MFA
func (c *Client) AccountWithdrawUsingMFA(ctx context.Context, body AccountWithdrawUsingMFARequest) (*AccountWithdrawUsingMFAResponseBody, error) {
	req, err := newAccountWithdrawUsingMFARequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[AccountWithdrawUsingMFAResponseBody](rsp)

}

// List Withdrawal Addresses
func (c *Client) ListWithdrawalAddresses(ctx context.Context) (*ListWithdrawalAddressesResponseBody, error) {
	req, err := newListWithdrawalAddressesRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ListWithdrawalAddressesResponseBody](rsp)

}

// Create Withdrawal Address
func (c *Client) CreateWithdrawalAddress(ctx context.Context, body CreateWithdrawalAddressRequest) (*CreateWithdrawalAddressResponseBody, error) {
	req, err := newCreateWithdrawalAddressRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateWithdrawalAddressResponseBody](rsp)

}

// Confirm Withdrawal Address
func (c *Client) ConfirmWithdrawalAddress(ctx context.Context, body ConfirmWithdrawalAddressRequest) (*ConfirmWithdrawalAddressResponseBody, error) {
	req, err := newConfirmWithdrawalAddressRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ConfirmWithdrawalAddressResponseBody](rsp)

}

// Delete Withdrawal Address
func (c *Client) DeleteWithdrawalAddress(ctx context.Context, id int) (*DeleteWithdrawalAddressResponseBody, error) {
	req, err := newDeleteWithdrawalAddressRequest(ctx, c.apiURL, c.keyPair, id)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[DeleteWithdrawalAddressResponseBody](rsp)

}

// Get Withdrawal Address
func (c *Client) GetWithdrawalAddress(ctx context.Context, id int) (*GetWithdrawalAddressResponseBody, error) {
	req, err := newGetWithdrawalAddressRequest(ctx, c.apiURL, c.keyPair, id)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetWithdrawalAddressResponseBody](rsp)

}

// Update Withdrawal Address Label
func (c *Client) UpdateWithdrawalAddressLabel(ctx context.Context, id int, body UpdateWithdrawalAddressLabelRequest) (*UpdateWithdrawalAddressLabelResponseBody, error) {
	req, err := newUpdateWithdrawalAddressLabelRequest(ctx, c.apiURL, c.keyPair, id, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UpdateWithdrawalAddressLabelResponseBody](rsp)

}

// Get Withdrawals
func (c *Client) GetAccountWithdrawals(ctx context.Context, params GetAccountWithdrawalsParams) (*GetAccountWithdrawalsResponseBody, error) {
	req, err := newGetAccountWithdrawalsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAccountWithdrawalsResponseBody](rsp)

}

// Commission earned for user
func (c *Client) CommissionsEarned(ctx context.Context) (*CommissionsEarnedResponseBody, error) {
	req, err := newCommissionsEarnedRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CommissionsEarnedResponseBody](rsp)

}

// Min ARKM last 30d for user
func (c *Client) MinArkmLast30d(ctx context.Context) (*MinArkmLast30dResponseBody, error) {
	req, err := newMinArkmLast30dRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[MinArkmLast30dResponseBody](rsp)

}

// Points leaderboard for user
func (c *Client) UserPoints(ctx context.Context) (*UserPointsResponseBody, error) {
	req, err := newUserPointsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserPointsResponseBody](rsp)

}

// Points leaderboard season 1 for user
func (c *Client) UserPointsSeason1(ctx context.Context) (*UserPointsSeason1ResponseBody, error) {
	req, err := newUserPointsSeason1Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserPointsSeason1ResponseBody](rsp)

}

// Points leaderboard season 2 for user
func (c *Client) UserPointsSeason2(ctx context.Context) (*UserPointsSeason2ResponseBody, error) {
	req, err := newUserPointsSeason2Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserPointsSeason2ResponseBody](rsp)

}

// Realized PnL for user
func (c *Client) RealizedPnl(ctx context.Context) (*RealizedPnlResponseBody, error) {
	req, err := newRealizedPnlRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[RealizedPnlResponseBody](rsp)

}

// Rebate balance for user
func (c *Client) RebateBalance(ctx context.Context) (*RebateBalanceResponseBody, error) {
	req, err := newRebateBalanceRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[RebateBalanceResponseBody](rsp)

}

// Referral count for user
func (c *Client) ReferralCount(ctx context.Context) (*ReferralCountResponseBody, error) {
	req, err := newReferralCountRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ReferralCountResponseBody](rsp)

}

// Referrals leaderboard season 1 for user
func (c *Client) UserReferralsSeason1(ctx context.Context) (*UserReferralsSeason1ResponseBody, error) {
	req, err := newUserReferralsSeason1Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserReferralsSeason1ResponseBody](rsp)

}

// Referrals leaderboard season 2 for user
func (c *Client) UserReferralsSeason2(ctx context.Context) (*UserReferralsSeason2ResponseBody, error) {
	req, err := newUserReferralsSeason2Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserReferralsSeason2ResponseBody](rsp)

}

// Trading volume stats for user
func (c *Client) TradingVolumeStats(ctx context.Context) (*TradingVolumeStatsResponseBody, error) {
	req, err := newTradingVolumeStatsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[TradingVolumeStatsResponseBody](rsp)

}

// Volume leaderboard season 1 for user
func (c *Client) UserVolumeSeason1(ctx context.Context) (*UserVolumeSeason1ResponseBody, error) {
	req, err := newUserVolumeSeason1Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserVolumeSeason1ResponseBody](rsp)

}

// Volume leaderboard season 2 for user
func (c *Client) UserVolumeSeason2(ctx context.Context) (*UserVolumeSeason2ResponseBody, error) {
	req, err := newUserVolumeSeason2Request(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UserVolumeSeason2ResponseBody](rsp)

}

// Get Airdrop Address
func (c *Client) GetAirdropAddress(ctx context.Context) (*GetAirdropAddressResponseBody, error) {
	req, err := newGetAirdropAddressRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAirdropAddressResponseBody](rsp)

}

// Create Airdrop Address
func (c *Client) CreateAirdropAddress(ctx context.Context, body CreateAirdropAddressRequest) (*CreateAirdropAddressResponseBody, error) {
	req, err := newCreateAirdropAddressRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateAirdropAddressResponseBody](rsp)

}

// Get Airdrop Claim
func (c *Client) GetAirdropClaim(ctx context.Context) (*GetAirdropClaimResponseBody, error) {
	req, err := newGetAirdropClaimRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAirdropClaimResponseBody](rsp)

}

// Api Key List
func (c *Client) ApiKeysList(ctx context.Context) (*ApiKeysListResponseBody, error) {
	req, err := newApiKeysListRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ApiKeysListResponseBody](rsp)

}

// Api Key Create
func (c *Client) ApiKeyCreate(ctx context.Context, body CreateApiKeyRequest) (*ApiKeyCreateResponseBody, error) {
	req, err := newApiKeyCreateRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ApiKeyCreateResponseBody](rsp)

}

// Api Key Update
func (c *Client) ApiKeyUpdate(ctx context.Context, id int, body ApiKeyUpdateRequest) (*ApiKeyUpdateResponseBody, error) {
	req, err := newApiKeyUpdateRequest(ctx, c.apiURL, c.keyPair, id, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ApiKeyUpdateResponseBody](rsp)

}

// Api Key Delete
func (c *Client) ApiKeysDelete(ctx context.Context, id int) error {
	req, err := newApiKeysDeleteRequest(ctx, c.apiURL, c.keyPair, id)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Opt in to competition
func (c *Client) CompetitionOptIn(ctx context.Context, body CompetitionOptInRequest) error {
	req, err := newCompetitionOptInRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Check competition opt-in status
func (c *Client) CompetitionOptInStatus(ctx context.Context, params CompetitionOptInStatusParams) (*CompetitionOptInStatusResponseBody, error) {
	req, err := newCompetitionOptInStatusRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CompetitionOptInStatusResponseBody](rsp)

}

// Get 0x allowance holder price
//
// Proxies the 0x Allowance Holder price endpoint with Arkham's affiliate fee configuration.
func (c *Client) DexPrice(ctx context.Context, params DexPriceParams) (*DexPriceResponseBody, error) {
	req, err := newDexPriceRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[DexPriceResponseBody](rsp)

}

// Get 0x allowance holder quote
//
// Proxies the 0x Allowance Holder firm quote endpoint with Arkham's affiliate fee configuration.
func (c *Client) DexQuote(ctx context.Context, params DexQuoteParams) (*DexQuoteResponseBody, error) {
	req, err := newDexQuoteRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[DexQuoteResponseBody](rsp)

}

// Submit DEX Trade
//
// Record a submitted DEX trade by ZID. Anonymous requests are stored without a user association when authentication is not present.
func (c *Client) DexSubmit(ctx context.Context, body DexSubmitRequest) error {
	req, err := newDexSubmitRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get DEX token list
//
// Returns a list of supported tokens for the DEX
func (c *Client) GetDexTokenList(ctx context.Context) (*GetDexTokenListResponseBody, error) {
	req, err := newGetDexTokenListRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetDexTokenListResponseBody](rsp)

}

// Get confirmed DEX trades
//
// Returns confirmed DEX trades for a taker address.
func (c *Client) DexTradeHistory(ctx context.Context, params DexTradeHistoryParams) (*DexTradeHistoryResponseBody, error) {
	req, err := newDexTradeHistoryRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[DexTradeHistoryResponseBody](rsp)

}

// Get Orders
func (c *Client) GetOrders(ctx context.Context, params GetOrdersParams) (*GetOrdersResponseBody, error) {
	req, err := newGetOrdersRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetOrdersResponseBody](rsp)

}

// Get Open Order By Client Order Id
func (c *Client) GetOpenOrderByClientOrderId(ctx context.Context, params GetOpenOrderByClientOrderIdParams) (*GetOpenOrderByClientOrderIdResponseBody, error) {
	req, err := newGetOpenOrderByClientOrderIdRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetOpenOrderByClientOrderIdResponseBody](rsp)

}

// Cancel Order
func (c *Client) CancelOrder(ctx context.Context, body CancelOrderRequest) (*CancelOrderResponseBody, error) {
	req, err := newCancelOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CancelOrderResponseBody](rsp)

}

// Cancel and Replace Order
func (c *Client) CancelReplaceOrder(ctx context.Context, body CancelReplaceOrderRequest) (*CancelReplaceOrderResponseBody, error) {
	req, err := newCancelReplaceOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CancelReplaceOrderResponseBody](rsp)

}

// Cancel All
func (c *Client) CancelAll(ctx context.Context, body CancelAllRequest) error {
	req, err := newCancelAllRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Order History
func (c *Client) GetOrderHistory(ctx context.Context, params GetOrderHistoryParams) (*GetOrderHistoryResponseBody, error) {
	req, err := newGetOrderHistoryRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetOrderHistoryResponseBody](rsp)

}

// Get all order for Client Order Id
func (c *Client) GetAllOrdersByClientOrderId(ctx context.Context, params GetAllOrdersByClientOrderIdParams) (*GetAllOrdersByClientOrderIdResponseBody, error) {
	req, err := newGetAllOrdersByClientOrderIdRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAllOrdersByClientOrderIdResponseBody](rsp)

}

// Get Total Orders
func (c *Client) GetOrderHistoryWithTotal(ctx context.Context, params GetOrderHistoryWithTotalParams) (*GetOrderHistoryWithTotalResponseBody, error) {
	req, err := newGetOrderHistoryWithTotalRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetOrderHistoryWithTotalResponseBody](rsp)

}

// Create Order
func (c *Client) CreateOrder(ctx context.Context, body CreateOrderRequest) (*CreateOrderResponseBody, error) {
	req, err := newCreateOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateOrderResponseBody](rsp)

}

// Create Multiple Orders
//
// Orders are processed sequentially and returned in the same order as the input requests.
func (c *Client) CreateOrderBatch(ctx context.Context, body CreateOrdersBatchRequest) (*CreateOrderBatchResponseBody, error) {
	req, err := newCreateOrderBatchRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateOrderBatchResponseBody](rsp)

}

// Create Simple Order
func (c *Client) CreateSimpleOrder(ctx context.Context, body CreateSimpleOrderRequest) (*CreateSimpleOrderResponseBody, error) {
	req, err := newCreateSimpleOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateSimpleOrderResponseBody](rsp)

}

// Get Order By Id
func (c *Client) GetOrderById(ctx context.Context, id int, params GetOrderByIdParams) (*GetOrderByIdResponseBody, error) {
	req, err := newGetOrderByIdRequest(ctx, c.apiURL, c.keyPair, id, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetOrderByIdResponseBody](rsp)

}

// Get Alerts
func (c *Client) GetAlerts(ctx context.Context) (*GetAlertsResponseBody, error) {
	req, err := newGetAlertsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAlertsResponseBody](rsp)

}

// Get Announcements
//
// Get announcements for a specific locale
func (c *Client) GetAnnouncements(ctx context.Context, params GetAnnouncementsParams) (*GetAnnouncementsResponseBody, error) {
	req, err := newGetAnnouncementsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAnnouncementsResponseBody](rsp)

}

// Get Assets
func (c *Client) GetAssets(ctx context.Context) (*GetAssetsResponseBody, error) {
	req, err := newGetAssetsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetAssetsResponseBody](rsp)

}

// Get Book
func (c *Client) GetBook(ctx context.Context, params GetBookParams) (*GetBookResponseBody, error) {
	req, err := newGetBookRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetBookResponseBody](rsp)

}

// Get Candles
func (c *Client) GetCandles(ctx context.Context, params GetCandlesParams) (*GetCandlesResponseBody, error) {
	req, err := newGetCandlesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetCandlesResponseBody](rsp)

}

// Get Chains
func (c *Client) GetChains(ctx context.Context) (*GetChainsResponseBody, error) {
	req, err := newGetChainsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetChainsResponseBody](rsp)

}

// Get Contracts
func (c *Client) GetContracts(ctx context.Context) (*GetContractsResponseBody, error) {
	req, err := newGetContractsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetContractsResponseBody](rsp)

}

// Get Index Price
func (c *Client) GetIndexPrice(ctx context.Context, params GetIndexPriceParams) (*GetIndexPriceResponseBody, error) {
	req, err := newGetIndexPriceRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetIndexPriceResponseBody](rsp)

}

// Get Index Prices
func (c *Client) GetIndexPrices(ctx context.Context) (*GetIndexPricesResponseBody, error) {
	req, err := newGetIndexPricesRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetIndexPricesResponseBody](rsp)

}

// Get L1 Book
func (c *Client) GetL1Book(ctx context.Context, params GetL1BookParams) (*GetL1BookResponseBody, error) {
	req, err := newGetL1BookRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetL1BookResponseBody](rsp)

}

// Get Margin Schedules
func (c *Client) GetMarginSchedules(ctx context.Context) (*GetMarginSchedulesResponseBody, error) {
	req, err := newGetMarginSchedulesRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetMarginSchedulesResponseBody](rsp)

}

// Get MarketCap Chart
func (c *Client) GetMarketCapChart(ctx context.Context) (*GetMarketCapChartResponseBody, error) {
	req, err := newGetMarketCapChartRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetMarketCapChartResponseBody](rsp)

}

// Get Market Caps
func (c *Client) GetMarketCaps(ctx context.Context) (*GetMarketCapsResponseBody, error) {
	req, err := newGetMarketCapsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetMarketCapsResponseBody](rsp)

}

// Get Pair
func (c *Client) GetPair(ctx context.Context, params GetPairParams) (*GetPairResponseBody, error) {
	req, err := newGetPairRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPairResponseBody](rsp)

}

// Get Pairs
func (c *Client) GetPairs(ctx context.Context) (*GetPairsResponseBody, error) {
	req, err := newGetPairsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPairsResponseBody](rsp)

}

// Get Server Time
func (c *Client) ServerTime(ctx context.Context) (*ServerTimeResponseBody, error) {
	req, err := newServerTimeRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[ServerTimeResponseBody](rsp)

}

// Get Ticker
func (c *Client) GetTicker(ctx context.Context, params GetTickerParams) (*GetTickerResponseBody, error) {
	req, err := newGetTickerRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetTickerResponseBody](rsp)

}

// Get Tickers
func (c *Client) GetTickers(ctx context.Context) (*GetTickersResponseBody, error) {
	req, err := newGetTickersRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetTickersResponseBody](rsp)

}

// Get Public Trades
func (c *Client) GetPublicTrades(ctx context.Context, params GetPublicTradesParams) (*GetPublicTradesResponseBody, error) {
	req, err := newGetPublicTradesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetPublicTradesResponseBody](rsp)

}

// Rewards info
func (c *Client) RewardsInfo(ctx context.Context) (*RewardsInfoResponseBody, error) {
	req, err := newRewardsInfoRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[RewardsInfoResponseBody](rsp)

}

// Vouchers for user
func (c *Client) Vouchers(ctx context.Context, params VouchersParams) (*VouchersResponseBody, error) {
	req, err := newVouchersRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[VouchersResponseBody](rsp)

}

// Claim voucher
func (c *Client) ClaimVoucher(ctx context.Context, body VoucherClaimRequest) error {
	req, err := newClaimVoucherRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get Subaccounts
func (c *Client) GetSubaccounts(ctx context.Context) (*GetSubaccountsResponseBody, error) {
	req, err := newGetSubaccountsRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetSubaccountsResponseBody](rsp)

}

// Create Subaccount
func (c *Client) CreateSubaccount(ctx context.Context, body CreateSubaccountRequest) (*CreateSubaccountResponseBody, error) {
	req, err := newCreateSubaccountRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateSubaccountResponseBody](rsp)

}

// Update Subaccount
func (c *Client) UpdateSubaccount(ctx context.Context, body UpdateSubaccountRequest) error {
	req, err := newUpdateSubaccountRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Create Perpetual Transfer
func (c *Client) CreatePerpTransfer(ctx context.Context, body CreatePerpTransferRequest) (*CreatePerpTransferResponseBody, error) {
	req, err := newCreatePerpTransferRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreatePerpTransferResponseBody](rsp)

}

// Create Transfer
func (c *Client) CreateTransfer(ctx context.Context, body CreateTransferRequest) (*CreateTransferResponseBody, error) {
	req, err := newCreateTransferRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateTransferResponseBody](rsp)

}

// Update Portfolio Settings
func (c *Client) UpdatePortfolioSettings(ctx context.Context, body SubaccountSettingsRequest) (*UpdatePortfolioSettingsResponseBody, error) {
	req, err := newUpdatePortfolioSettingsRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[UpdatePortfolioSettingsResponseBody](rsp)

}

// Delete Subaccount
//
// Deletes the specified subaccount by ID
func (c *Client) DeleteSubaccount(ctx context.Context, subaccountId int) error {
	req, err := newDeleteSubaccountRequest(ctx, c.apiURL, c.keyPair, subaccountId)
	if err != nil {
		return err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return err
	}

	return nil

}

// Get User Trades
func (c *Client) GetUserTrades(ctx context.Context, params GetUserTradesParams) (*GetUserTradesResponseBody, error) {
	req, err := newGetUserTradesRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserTradesResponseBody](rsp)

}

// Get User Trades History
func (c *Client) GetUserTradesWithTotals(ctx context.Context, params GetUserTradesWithTotalsParams) (*GetUserTradesWithTotalsResponseBody, error) {
	req, err := newGetUserTradesWithTotalsRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserTradesWithTotalsResponseBody](rsp)

}

// Get User Trades By Time
func (c *Client) GetUserTradesByTime(ctx context.Context, params GetUserTradesByTimeParams) (*GetUserTradesByTimeResponseBody, error) {
	req, err := newGetUserTradesByTimeRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserTradesByTimeResponseBody](rsp)

}

// Get Trigger Orders
//
// Get all trigger orders for the authenticated user.
func (c *Client) GetTriggerOrders(ctx context.Context, params GetTriggerOrdersParams) (*GetTriggerOrdersResponseBody, error) {
	req, err := newGetTriggerOrdersRequest(ctx, c.apiURL, c.keyPair, params)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetTriggerOrdersResponseBody](rsp)

}

// Cancel Trigger Order
func (c *Client) CancelTriggerOrder(ctx context.Context, body CancelTriggerOrderRequest) (*CancelTriggerOrderResponseBody, error) {
	req, err := newCancelTriggerOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CancelTriggerOrderResponseBody](rsp)

}

// Cancel AllTrigger Orders
func (c *Client) CancelAllTriggerOrders(ctx context.Context, body CancelAllTriggerOrdersRequest) (*CancelAllTriggerOrdersResponseBody, error) {
	req, err := newCancelAllTriggerOrdersRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CancelAllTriggerOrdersResponseBody](rsp)

}

// Create Trigger Order
func (c *Client) CreateTriggerOrder(ctx context.Context, body CreateTriggerOrderRequest) (*CreateTriggerOrderResponseBody, error) {
	req, err := newCreateTriggerOrderRequest(ctx, c.apiURL, c.keyPair, body)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[CreateTriggerOrderResponseBody](rsp)

}

// Get User
func (c *Client) GetUser(ctx context.Context) (*GetUserResponseBody, error) {
	req, err := newGetUserRequest(ctx, c.apiURL, c.keyPair)
	if err != nil {
		return nil, err
	}
	rsp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	if err := handleErrorResponses(rsp); err != nil {
		return nil, err
	}

	return parseResponseBody[GetUserResponseBody](rsp)

}

// newGetAccountAirdropsRequest generates requests for GetAccountAirdrops
func newGetAccountAirdropsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountAirdropsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/airdrops"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountBalanceUpdatesRequest generates requests for GetAccountBalanceUpdates
func newGetAccountBalanceUpdatesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountBalanceUpdatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/balance-updates"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason", runtime.ParamLocationQuery, params.Reason); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetBalancesRequest generates requests for GetBalances
func newGetBalancesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetBalancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/balances"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAllBalancesRequest generates requests for GetAllBalances
func newGetAllBalancesRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/balances/all"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPortfolioBalanceHistoryRequest generates requests for GetPortfolioBalanceHistory
func newGetPortfolioBalanceHistoryRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPortfolioBalanceHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/balances/history"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountCommissionsRequest generates requests for GetAccountCommissions
func newGetAccountCommissionsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountCommissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/commissions"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetDepositAddressesRequest generates requests for GetDepositAddresses
func newGetDepositAddressesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetDepositAddressesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/deposit/addresses"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chain", runtime.ParamLocationQuery, params.Chain); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newNewDepositAddressRequest calls the generic NewDepositAddress builder with application/json body
func newNewDepositAddressRequest(ctx context.Context, server string, keyPair *KeyPair, body NewDepositAddressRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newNewDepositAddressRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newNewDepositAddressRequestWithBody generates requests for NewDepositAddress with any type of body
func newNewDepositAddressRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/deposit/addresses/new"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetAccountDepositsRequest generates requests for GetAccountDeposits
func newGetAccountDepositsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountDepositsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/deposits"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetUserFeesRequest generates requests for GetUserFees
func newGetUserFeesRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/fees"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetFundingRatePaymentsRequest generates requests for GetFundingRatePayments
func newGetFundingRatePaymentsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetFundingRatePaymentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/funding-rate-payments"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPositionLeverageRequest generates requests for GetPositionLeverage
func newGetPositionLeverageRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPositionLeverageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/leverage"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newSetPositionLeverageRequest calls the generic SetPositionLeverage builder with application/json body
func newSetPositionLeverageRequest(ctx context.Context, server string, keyPair *KeyPair, body SetPositionLeverageRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newSetPositionLeverageRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newSetPositionLeverageRequestWithBody generates requests for SetPositionLeverage with any type of body
func newSetPositionLeverageRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/leverage"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetLiquidationPriceRequest generates requests for GetLiquidationPrice
func newGetLiquidationPriceRequest(ctx context.Context, server string, keyPair *KeyPair, params GetLiquidationPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/liquidation-price"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountLspAssignmentsRequest generates requests for GetAccountLspAssignments
func newGetAccountLspAssignmentsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountLspAssignmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/lsp-assignments"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetMarginRequest generates requests for GetMargin
func newGetMarginRequest(ctx context.Context, server string, keyPair *KeyPair, params GetMarginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/margin"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAllMarginRequest generates requests for GetAllMargin
func newGetAllMarginRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/margin/all"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetNotificationsRequest generates requests for GetNotifications
func newGetNotificationsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetNotificationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/notifications"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newMarkReadNotificationsRequest calls the generic MarkReadNotifications builder with application/json body
func newMarkReadNotificationsRequest(ctx context.Context, server string, keyPair *KeyPair, body MarkReadNotificationsRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newMarkReadNotificationsRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newMarkReadNotificationsRequestWithBody generates requests for MarkReadNotifications with any type of body
func newMarkReadNotificationsRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/notifications/read"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetAccountPositionUpdatesRequest generates requests for GetAccountPositionUpdates
func newGetAccountPositionUpdatesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountPositionUpdatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/position-updates"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason", runtime.ParamLocationQuery, params.Reason); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPositionsRequest generates requests for GetPositions
func newGetPositionsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPositionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/positions"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountRealizedPnlRequest generates requests for GetAccountRealizedPnl
func newGetAccountRealizedPnlRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountRealizedPnlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/realized-pnl"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountRebatesRequest generates requests for GetAccountRebates
func newGetAccountRebatesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountRebatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/rebates"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetReferralLinksRequest generates requests for GetReferralLinks
func newGetReferralLinksRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/referral-links"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCreateReferralLinkRequest generates requests for CreateReferralLink
func newCreateReferralLinkRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/referral-links"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUpdateReferralLinkSlugRequest calls the generic UpdateReferralLinkSlug builder with application/json body
func newUpdateReferralLinkSlugRequest(ctx context.Context, server string, keyPair *KeyPair, id string, body UpdateReferralLinkSlugRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newUpdateReferralLinkSlugRequestWithBody(ctx, server, keyPair, id, "application/json", buf)
}

// newUpdateReferralLinkSlugRequestWithBody generates requests for UpdateReferralLinkSlug with any type of body
func newUpdateReferralLinkSlugRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, id string, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/referral-links/%s/slug", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("PUT", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetActiveSessionsRequest generates requests for GetActiveSessions
func newGetActiveSessionsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/sessions"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newHandleDeleteSessionRequest calls the generic HandleDeleteSession builder with application/json body
func newHandleDeleteSessionRequest(ctx context.Context, server string, keyPair *KeyPair, body DeleteSessionRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newHandleDeleteSessionRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newHandleDeleteSessionRequestWithBody generates requests for HandleDeleteSession with any type of body
func newHandleDeleteSessionRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/sessions/delete"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newHandleTerminateAllRequest generates requests for HandleTerminateAll
func newHandleTerminateAllRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/sessions/terminate-all"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetUserSettingsRequest generates requests for GetUserSettings
func newGetUserSettingsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/settings"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newDeletePriceAlertRequest generates requests for DeletePriceAlert
func newDeletePriceAlertRequest(ctx context.Context, server string, keyPair *KeyPair, params DeletePriceAlertParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/settings/price-alert"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("DELETE", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPriceAlertRequest generates requests for GetPriceAlert
func newGetPriceAlertRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPriceAlertParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/settings/price-alert"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newSetPriceAlertRequest calls the generic SetPriceAlert builder with application/json body
func newSetPriceAlertRequest(ctx context.Context, server string, keyPair *KeyPair, params SetPriceAlertParams, body SetPriceAlertRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newSetPriceAlertRequestWithBody(ctx, server, keyPair, params, "application/json", buf)
}

// newSetPriceAlertRequestWithBody generates requests for SetPriceAlert with any type of body
func newSetPriceAlertRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, params SetPriceAlertParams, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/settings/price-alert"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("PUT", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newUpdateUserSettingsRequest calls the generic UpdateUserSettings builder with application/json body
func newUpdateUserSettingsRequest(ctx context.Context, server string, keyPair *KeyPair, body UpdateUserSettingsRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newUpdateUserSettingsRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newUpdateUserSettingsRequestWithBody generates requests for UpdateUserSettings with any type of body
func newUpdateUserSettingsRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/settings/update"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetAccountTransfersRequest generates requests for GetAccountTransfers
func newGetAccountTransfersRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountTransfersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/transfers"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newHandleReminderEmailUnsubscribeRequest generates requests for HandleReminderEmailUnsubscribe
func newHandleReminderEmailUnsubscribeRequest(ctx context.Context, server string, keyPair *KeyPair, params HandleReminderEmailUnsubscribeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/unsubscribe"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkId", runtime.ParamLocationQuery, params.LinkId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAccountWatchlistRequest generates requests for GetAccountWatchlist
func newGetAccountWatchlistRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/watchlist"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newAddToWatchlistRequest calls the generic AddToWatchlist builder with application/json body
func newAddToWatchlistRequest(ctx context.Context, server string, keyPair *KeyPair, body AddToWatchlistRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newAddToWatchlistRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newAddToWatchlistRequestWithBody generates requests for AddToWatchlist with any type of body
func newAddToWatchlistRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/watchlist/add"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newRemoveFromWatchlistRequest calls the generic RemoveFromWatchlist builder with application/json body
func newRemoveFromWatchlistRequest(ctx context.Context, server string, keyPair *KeyPair, body RemoveFromWatchlistRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newRemoveFromWatchlistRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newRemoveFromWatchlistRequestWithBody generates requests for RemoveFromWatchlist with any type of body
func newRemoveFromWatchlistRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/watchlist/remove"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newAccountWithdrawRequest calls the generic AccountWithdraw builder with application/json body
func newAccountWithdrawRequest(ctx context.Context, server string, keyPair *KeyPair, body AccountWithdrawRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newAccountWithdrawRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newAccountWithdrawRequestWithBody generates requests for AccountWithdraw with any type of body
func newAccountWithdrawRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdraw"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newAccountWithdrawUsingMFARequest calls the generic AccountWithdrawUsingMFA builder with application/json body
func newAccountWithdrawUsingMFARequest(ctx context.Context, server string, keyPair *KeyPair, body AccountWithdrawUsingMFARequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newAccountWithdrawUsingMFARequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newAccountWithdrawUsingMFARequestWithBody generates requests for AccountWithdrawUsingMFA with any type of body
func newAccountWithdrawUsingMFARequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdraw/with-mfa"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newListWithdrawalAddressesRequest generates requests for ListWithdrawalAddresses
func newListWithdrawalAddressesRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdrawal/addresses"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCreateWithdrawalAddressRequest calls the generic CreateWithdrawalAddress builder with application/json body
func newCreateWithdrawalAddressRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateWithdrawalAddressRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateWithdrawalAddressRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateWithdrawalAddressRequestWithBody generates requests for CreateWithdrawalAddress with any type of body
func newCreateWithdrawalAddressRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdrawal/addresses"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newConfirmWithdrawalAddressRequest calls the generic ConfirmWithdrawalAddress builder with application/json body
func newConfirmWithdrawalAddressRequest(ctx context.Context, server string, keyPair *KeyPair, body ConfirmWithdrawalAddressRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newConfirmWithdrawalAddressRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newConfirmWithdrawalAddressRequestWithBody generates requests for ConfirmWithdrawalAddress with any type of body
func newConfirmWithdrawalAddressRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdrawal/addresses/confirm"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newDeleteWithdrawalAddressRequest generates requests for DeleteWithdrawalAddress
func newDeleteWithdrawalAddressRequest(ctx context.Context, server string, keyPair *KeyPair, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/withdrawal/addresses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("DELETE", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetWithdrawalAddressRequest generates requests for GetWithdrawalAddress
func newGetWithdrawalAddressRequest(ctx context.Context, server string, keyPair *KeyPair, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/withdrawal/addresses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUpdateWithdrawalAddressLabelRequest calls the generic UpdateWithdrawalAddressLabel builder with application/json body
func newUpdateWithdrawalAddressLabelRequest(ctx context.Context, server string, keyPair *KeyPair, id int, body UpdateWithdrawalAddressLabelRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newUpdateWithdrawalAddressLabelRequestWithBody(ctx, server, keyPair, id, "application/json", buf)
}

// newUpdateWithdrawalAddressLabelRequestWithBody generates requests for UpdateWithdrawalAddressLabel with any type of body
func newUpdateWithdrawalAddressLabelRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, id int, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/account/withdrawal/addresses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("PUT", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetAccountWithdrawalsRequest generates requests for GetAccountWithdrawals
func newGetAccountWithdrawalsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAccountWithdrawalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/account/withdrawals"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCommissionsEarnedRequest generates requests for CommissionsEarned
func newCommissionsEarnedRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/commission-earned"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newMinArkmLast30dRequest generates requests for MinArkmLast30d
func newMinArkmLast30dRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/min-arkm-last-30d"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserPointsRequest generates requests for UserPoints
func newUserPointsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/points"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserPointsSeason1Request generates requests for UserPointsSeason1
func newUserPointsSeason1Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/points-season-1"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserPointsSeason2Request generates requests for UserPointsSeason2
func newUserPointsSeason2Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/points-season-2"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newRealizedPnlRequest generates requests for RealizedPnl
func newRealizedPnlRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/realized-pnl"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newRebateBalanceRequest generates requests for RebateBalance
func newRebateBalanceRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/rebate-balance"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newReferralCountRequest generates requests for ReferralCount
func newReferralCountRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/referral-count"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserReferralsSeason1Request generates requests for UserReferralsSeason1
func newUserReferralsSeason1Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/referrals-season-1"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserReferralsSeason2Request generates requests for UserReferralsSeason2
func newUserReferralsSeason2Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/referrals-season-2"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newTradingVolumeStatsRequest generates requests for TradingVolumeStats
func newTradingVolumeStatsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/trading-volume-stats"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserVolumeSeason1Request generates requests for UserVolumeSeason1
func newUserVolumeSeason1Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/volume-season-1"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newUserVolumeSeason2Request generates requests for UserVolumeSeason2
func newUserVolumeSeason2Request(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/affiliate-dashboard/volume-season-2"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAirdropAddressRequest generates requests for GetAirdropAddress
func newGetAirdropAddressRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/airdrop"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCreateAirdropAddressRequest calls the generic CreateAirdropAddress builder with application/json body
func newCreateAirdropAddressRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateAirdropAddressRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateAirdropAddressRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateAirdropAddressRequestWithBody generates requests for CreateAirdropAddress with any type of body
func newCreateAirdropAddressRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/airdrop"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetAirdropClaimRequest generates requests for GetAirdropClaim
func newGetAirdropClaimRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/airdrop/claim"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newApiKeysListRequest generates requests for ApiKeysList
func newApiKeysListRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/api-key"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newApiKeyCreateRequest calls the generic ApiKeyCreate builder with application/json body
func newApiKeyCreateRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateApiKeyRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newApiKeyCreateRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newApiKeyCreateRequestWithBody generates requests for ApiKeyCreate with any type of body
func newApiKeyCreateRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/api-key/create"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newApiKeyUpdateRequest calls the generic ApiKeyUpdate builder with application/json body
func newApiKeyUpdateRequest(ctx context.Context, server string, keyPair *KeyPair, id int, body ApiKeyUpdateRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newApiKeyUpdateRequestWithBody(ctx, server, keyPair, id, "application/json", buf)
}

// newApiKeyUpdateRequestWithBody generates requests for ApiKeyUpdate with any type of body
func newApiKeyUpdateRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, id int, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-key/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("PUT", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newApiKeysDeleteRequest generates requests for ApiKeysDelete
func newApiKeysDeleteRequest(ctx context.Context, server string, keyPair *KeyPair, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api-key/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("DELETE", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newAuthenticateRequestWithBody generates requests for Authenticate with any type of body
func newAuthenticateRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, params AuthenticateParams, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/authenticate"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tradeInToken", runtime.ParamLocationQuery, params.TradeInToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirectPath", runtime.ParamLocationQuery, params.RedirectPath); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCompetitionOptInRequest calls the generic CompetitionOptIn builder with application/json body
func newCompetitionOptInRequest(ctx context.Context, server string, keyPair *KeyPair, body CompetitionOptInRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCompetitionOptInRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCompetitionOptInRequestWithBody generates requests for CompetitionOptIn with any type of body
func newCompetitionOptInRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/competitions/opt-in"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCompetitionOptInStatusRequest generates requests for CompetitionOptInStatus
func newCompetitionOptInStatusRequest(ctx context.Context, server string, keyPair *KeyPair, params CompetitionOptInStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/competitions/opt-in-status"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "competition_id", runtime.ParamLocationQuery, params.CompetitionId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newDexPriceRequest generates requests for DexPrice
func newDexPriceRequest(ctx context.Context, server string, keyPair *KeyPair, params DexPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/dex/price"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chainId", runtime.ParamLocationQuery, params.ChainId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellToken", runtime.ParamLocationQuery, params.SellToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyToken", runtime.ParamLocationQuery, params.BuyToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellAmount", runtime.ParamLocationQuery, params.SellAmount); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, params.Taker); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, params.SlippageBps); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newDexQuoteRequest generates requests for DexQuote
func newDexQuoteRequest(ctx context.Context, server string, keyPair *KeyPair, params DexQuoteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/dex/quote"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chainId", runtime.ParamLocationQuery, params.ChainId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellToken", runtime.ParamLocationQuery, params.SellToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "buyToken", runtime.ParamLocationQuery, params.BuyToken); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sellAmount", runtime.ParamLocationQuery, params.SellAmount); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taker", runtime.ParamLocationQuery, params.Taker); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slippageBps", runtime.ParamLocationQuery, params.SlippageBps); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newDexSubmitRequest calls the generic DexSubmit builder with application/json body
func newDexSubmitRequest(ctx context.Context, server string, keyPair *KeyPair, body DexSubmitRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newDexSubmitRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newDexSubmitRequestWithBody generates requests for DexSubmit with any type of body
func newDexSubmitRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/dex/submit"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetDexTokenListRequest generates requests for GetDexTokenList
func newGetDexTokenListRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/dex/token-list"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newDexTradeHistoryRequest generates requests for DexTradeHistory
func newDexTradeHistoryRequest(ctx context.Context, server string, keyPair *KeyPair, params DexTradeHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/dex/trades"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, params.Address); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chainId", runtime.ParamLocationQuery, params.ChainId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetOrdersRequest generates requests for GetOrders
func newGetOrdersRequest(ctx context.Context, server string, keyPair *KeyPair, params GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetOpenOrderByClientOrderIdRequest generates requests for GetOpenOrderByClientOrderId
func newGetOpenOrderByClientOrderIdRequest(ctx context.Context, server string, keyPair *KeyPair, params GetOpenOrderByClientOrderIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/by-client-order-id"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientOrderId", runtime.ParamLocationQuery, params.ClientOrderId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCancelOrderRequest calls the generic CancelOrder builder with application/json body
func newCancelOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CancelOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCancelOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCancelOrderRequestWithBody generates requests for CancelOrder with any type of body
func newCancelOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/cancel"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCancelReplaceOrderRequest calls the generic CancelReplaceOrder builder with application/json body
func newCancelReplaceOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CancelReplaceOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCancelReplaceOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCancelReplaceOrderRequestWithBody generates requests for CancelReplaceOrder with any type of body
func newCancelReplaceOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/cancel-replace"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCancelAllRequest calls the generic CancelAll builder with application/json body
func newCancelAllRequest(ctx context.Context, server string, keyPair *KeyPair, body CancelAllRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCancelAllRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCancelAllRequestWithBody generates requests for CancelAll with any type of body
func newCancelAllRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/cancel/all"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetOrderHistoryRequest generates requests for GetOrderHistory
func newGetOrderHistoryRequest(ctx context.Context, server string, keyPair *KeyPair, params GetOrderHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/history"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAllOrdersByClientOrderIdRequest generates requests for GetAllOrdersByClientOrderId
func newGetAllOrdersByClientOrderIdRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAllOrdersByClientOrderIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/history/by-client-order-id"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clientOrderId", runtime.ParamLocationQuery, params.ClientOrderId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetOrderHistoryWithTotalRequest generates requests for GetOrderHistoryWithTotal
func newGetOrderHistoryWithTotalRequest(ctx context.Context, server string, keyPair *KeyPair, params GetOrderHistoryWithTotalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/history_offset"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCreateOrderRequest calls the generic CreateOrder builder with application/json body
func newCreateOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateOrderRequestWithBody generates requests for CreateOrder with any type of body
func newCreateOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/new"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCreateOrderBatchRequest calls the generic CreateOrderBatch builder with application/json body
func newCreateOrderBatchRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateOrdersBatchRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateOrderBatchRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateOrderBatchRequestWithBody generates requests for CreateOrderBatch with any type of body
func newCreateOrderBatchRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/new/batch"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCreateSimpleOrderRequest calls the generic CreateSimpleOrder builder with application/json body
func newCreateSimpleOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateSimpleOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateSimpleOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateSimpleOrderRequestWithBody generates requests for CreateSimpleOrder with any type of body
func newCreateSimpleOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/orders/new/simple"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetOrderByIdRequest generates requests for GetOrderById
func newGetOrderByIdRequest(ctx context.Context, server string, keyPair *KeyPair, id int, params GetOrderByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAlertsRequest generates requests for GetAlerts
func newGetAlertsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/alerts"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAnnouncementsRequest generates requests for GetAnnouncements
func newGetAnnouncementsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetAnnouncementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/announcements"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, params.Locale); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetAssetsRequest generates requests for GetAssets
func newGetAssetsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/assets"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetBookRequest generates requests for GetBook
func newGetBookRequest(ctx context.Context, server string, keyPair *KeyPair, params GetBookParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/book"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetCandlesRequest generates requests for GetCandles
func newGetCandlesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetCandlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/candles"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, params.Duration); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, params.Start); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, params.End); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetChainsRequest generates requests for GetChains
func newGetChainsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/chains"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetContractsRequest generates requests for GetContracts
func newGetContractsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/contracts"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetIndexPriceRequest generates requests for GetIndexPrice
func newGetIndexPriceRequest(ctx context.Context, server string, keyPair *KeyPair, params GetIndexPriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/index-price"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetIndexPricesRequest generates requests for GetIndexPrices
func newGetIndexPricesRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/index-prices"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetL1BookRequest generates requests for GetL1Book
func newGetL1BookRequest(ctx context.Context, server string, keyPair *KeyPair, params GetL1BookParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/level-one-book"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetMarginSchedulesRequest generates requests for GetMarginSchedules
func newGetMarginSchedulesRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/margin-schedules"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetMarketCapChartRequest generates requests for GetMarketCapChart
func newGetMarketCapChartRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/marketcapchart"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetMarketCapsRequest generates requests for GetMarketCaps
func newGetMarketCapsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/marketcaps"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPairRequest generates requests for GetPair
func newGetPairRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPairParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/pair"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPairsRequest generates requests for GetPairs
func newGetPairsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/pairs"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newServerTimeRequest generates requests for ServerTime
func newServerTimeRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/server-time"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetTickerRequest generates requests for GetTicker
func newGetTickerRequest(ctx context.Context, server string, keyPair *KeyPair, params GetTickerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/ticker"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetTickersRequest generates requests for GetTickers
func newGetTickersRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/tickers"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetPublicTradesRequest generates requests for GetPublicTrades
func newGetPublicTradesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetPublicTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/public/trades"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newRewardsInfoRequest generates requests for RewardsInfo
func newRewardsInfoRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/rewards/info"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newVouchersRequest generates requests for Vouchers
func newVouchersRequest(ctx context.Context, server string, keyPair *KeyPair, params VouchersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/rewards/vouchers"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "claimed", runtime.ParamLocationQuery, params.Claimed); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, params.Locale); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newClaimVoucherRequest calls the generic ClaimVoucher builder with application/json body
func newClaimVoucherRequest(ctx context.Context, server string, keyPair *KeyPair, body VoucherClaimRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newClaimVoucherRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newClaimVoucherRequestWithBody generates requests for ClaimVoucher with any type of body
func newClaimVoucherRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/rewards/vouchers/claim"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetSubaccountsRequest generates requests for GetSubaccounts
func newGetSubaccountsRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCreateSubaccountRequest calls the generic CreateSubaccount builder with application/json body
func newCreateSubaccountRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateSubaccountRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateSubaccountRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateSubaccountRequestWithBody generates requests for CreateSubaccount with any type of body
func newCreateSubaccountRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newUpdateSubaccountRequest calls the generic UpdateSubaccount builder with application/json body
func newUpdateSubaccountRequest(ctx context.Context, server string, keyPair *KeyPair, body UpdateSubaccountRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newUpdateSubaccountRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newUpdateSubaccountRequestWithBody generates requests for UpdateSubaccount with any type of body
func newUpdateSubaccountRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("PUT", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCreatePerpTransferRequest calls the generic CreatePerpTransfer builder with application/json body
func newCreatePerpTransferRequest(ctx context.Context, server string, keyPair *KeyPair, body CreatePerpTransferRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreatePerpTransferRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreatePerpTransferRequestWithBody generates requests for CreatePerpTransfer with any type of body
func newCreatePerpTransferRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts/perp-transfer"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCreateTransferRequest calls the generic CreateTransfer builder with application/json body
func newCreateTransferRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateTransferRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateTransferRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateTransferRequestWithBody generates requests for CreateTransfer with any type of body
func newCreateTransferRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts/transfer"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newUpdatePortfolioSettingsRequest calls the generic UpdatePortfolioSettings builder with application/json body
func newUpdatePortfolioSettingsRequest(ctx context.Context, server string, keyPair *KeyPair, body SubaccountSettingsRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newUpdatePortfolioSettingsRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newUpdatePortfolioSettingsRequestWithBody generates requests for UpdatePortfolioSettings with any type of body
func newUpdatePortfolioSettingsRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/subaccounts/update-settings"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newDeleteSubaccountRequest generates requests for DeleteSubaccount
func newDeleteSubaccountRequest(ctx context.Context, server string, keyPair *KeyPair, subaccountId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subaccountId", runtime.ParamLocationPath, subaccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subaccounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("DELETE", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetUserTradesRequest generates requests for GetUserTrades
func newGetUserTradesRequest(ctx context.Context, server string, keyPair *KeyPair, params GetUserTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trades"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, params.Before); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetUserTradesWithTotalsRequest generates requests for GetUserTradesWithTotals
func newGetUserTradesWithTotalsRequest(ctx context.Context, server string, keyPair *KeyPair, params GetUserTradesWithTotalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trades/history"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, params.Symbol); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetUserTradesByTimeRequest generates requests for GetUserTradesByTime
func newGetUserTradesByTimeRequest(ctx context.Context, server string, keyPair *KeyPair, params GetUserTradesByTimeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trades/time"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newGetTriggerOrdersRequest generates requests for GetTriggerOrders
func newGetTriggerOrdersRequest(ctx context.Context, server string, keyPair *KeyPair, params GetTriggerOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trigger-orders"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subaccountId", runtime.ParamLocationQuery, params.SubaccountId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

// newCancelTriggerOrderRequest calls the generic CancelTriggerOrder builder with application/json body
func newCancelTriggerOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CancelTriggerOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCancelTriggerOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCancelTriggerOrderRequestWithBody generates requests for CancelTriggerOrder with any type of body
func newCancelTriggerOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trigger-orders/cancel"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCancelAllTriggerOrdersRequest calls the generic CancelAllTriggerOrders builder with application/json body
func newCancelAllTriggerOrdersRequest(ctx context.Context, server string, keyPair *KeyPair, body CancelAllTriggerOrdersRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCancelAllTriggerOrdersRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCancelAllTriggerOrdersRequestWithBody generates requests for CancelAllTriggerOrders with any type of body
func newCancelAllTriggerOrdersRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trigger-orders/cancel/all"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newCreateTriggerOrderRequest calls the generic CreateTriggerOrder builder with application/json body
func newCreateTriggerOrderRequest(ctx context.Context, server string, keyPair *KeyPair, body CreateTriggerOrderRequest) (*http.Request, error) {
	buf := new(bytes.Buffer)
	if err := json.NewEncoder(buf).Encode(body); err != nil {
		return nil, err
	}
	return newCreateTriggerOrderRequestWithBody(ctx, server, keyPair, "application/json", buf)
}

// newCreateTriggerOrderRequestWithBody generates requests for CreateTriggerOrder with any type of body
func newCreateTriggerOrderRequestWithBody(ctx context.Context, server string, keyPair *KeyPair, contentType string, body *bytes.Buffer) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/trigger-orders/new"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("POST", req.URL.RequestURI(), body.Bytes(), req.Header); err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// newGetUserRequest generates requests for GetUser
func newGetUserRequest(ctx context.Context, server string, keyPair *KeyPair) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := "/user"
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if err := keyPair.signHeaders("GET", req.URL.RequestURI(), nil, req.Header); err != nil {
		return nil, err
	}

	return req, nil
}

func handleErrorResponses(rsp *http.Response) error {
	// Handle error responses
	if rsp.StatusCode < 200 || rsp.StatusCode >= 300 {
		var apiErr *Error
		if err := json.NewDecoder(rsp.Body).Decode(&apiErr); err != nil {
			return fmt.Errorf("decoding error response: %w", err)
		}
		return apiErr
	}
	return nil
}

func parseResponseBody[T any](rsp *http.Response) (*T, error) {

	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, fmt.Errorf("reading response body: %w", err)
	}

	var dest T
	if err := json.Unmarshal(bodyBytes, &dest); err != nil {
		return nil, fmt.Errorf("unmarshaling response body: %w", err)
	}
	return &dest, nil
}
